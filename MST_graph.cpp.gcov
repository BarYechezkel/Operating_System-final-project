        -:    0:Source:MST_graph.cpp
        -:    1:#include "MST_graph.hpp"
        -:    2:
        -:    3:// Helper function to perform DFS and accumulate the path weight between two vertices
       24:    4:bool dfs(int current, int target, const vector<vector<tuple<int, int, int>>>& adj, vector<bool>& visited, int& path_weight) {
       24:    5:    if (current == target) return true;  // Found the target vertex
        -:    6:
       15:    7:    visited[current] = true;
        -:    8:
       24:    9:    for (const auto& edge : adj[current]) {
        -:   10:        int to, weight, id;
       21:   11:        tie(to, weight, id) = edge;
        -:   12:
       21:   13:        if (!visited[to]) {
       15:   14:            path_weight += weight;  // Accumulate the weight
        -:   15:
        -:   16:            // Recursively search for the target vertex
       15:   17:            if (dfs(to, target, adj, visited, path_weight)) {
       12:   18:                return true;  // Return true if target found
        -:   19:            }
        -:   20:
        3:   21:            path_weight -= weight;  // Backtrack if the path does not lead to the target
        -:   22:        }
        -:   23:    }
        3:   24:    return false;  // Return false if target vertex not found
        -:   25:}
        -:   26:
        -:   27:// Function to generate the matrix of total path weights between every pair of vertices
        3:   28:vector<vector<int>> calculateWeightMatrix(int n, const vector<tuple<int, int, int, int>>& edges) {
        3:   29:    vector<vector<tuple<int, int, int>>> adj(n);             // Using tuple directly for adjacency list
        6:   30:    vector<vector<int>> weightMatrix(n, vector<int>(n, 0));  // Initialize the weight matrix
        -:   31:
        -:   32:    // Build the adjacency list for the tree from the edges
        9:   33:    for (const auto& e : edges) {
        -:   34:        int u, v, w, id;
        6:   35:        tie(u, v, w, id) = e;
        6:   36:        adj[u].emplace_back(v, w, id);
        6:   37:        adj[v].emplace_back(u, w, id);
        -:   38:    }
        -:   39:
        -:   40:    // Calculate the weight between all pairs of vertices
       12:   41:    for (int i = 0; i < n; ++i) {
       18:   42:        for (int j = i + 1; j < n; ++j) {
        9:   43:            vector<bool> visited(n, false);
        9:   44:            int path_weight = 0;
        9:   45:            if (dfs(i, j, adj, visited, path_weight)) {
        9:   46:                weightMatrix[i][j] = weightMatrix[j][i] = path_weight;  // Symmetric matrix
        -:   47:            }
        9:   48:        }
        -:   49:    }
        6:   50:    return weightMatrix;
        3:   51:}
        -:   52:
        3:   53:MST_graph::MST_graph(vector<tuple<int, int, int, int>> edges, string strategy) {
        3:   54:    this->edges = edges;
        3:   55:    numVertices = edges.size() + 1;
        3:   56:    alldistances = calculateWeightMatrix(edges.size() + 1, edges);
        3:   57:    this->strategy = strategy;
        3:   58:}
        -:   59:
        -:   60:// Function to convert the MST graph to a string
        3:   61:string MST_graph::toString() const{
        3:   62:    string ans;
        3:   63:    vector<tuple<int, int, int, int>> edges = this->getEdges();
        -:   64:
        9:   65:    for (const auto &e : edges) {
        -:   66:        int u, v, w, id;
        6:   67:        tie(u, v, w, id) = e;
        6:   68:        ans += "Edge " + std::to_string(id) + ": " + std::to_string(u) + " " + std::to_string(v) + " " + std::to_string(w) + "\n";
        -:   69:    }
        -:   70:
        6:   71:    return ans;
        3:   72:}
