        -:    0:Source:Pipeline.cpp
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:1
        -:    1:#include <sys/socket.h>  // Include this header for the send function
        -:    2:#include <sys/types.h>
        -:    3:
        -:    4:#include <condition_variable>
        -:    5:#include <functional>
        -:    6:#include <iostream>
        -:    7:#include <memory>
        -:    8:#include <mutex>
        -:    9:#include <queue>
        -:   10:#include <sstream>
        -:   11:#include <thread>
        -:   12:#include <vector>
        -:   13:
        -:   14:#include "Graph.cpp"
        -:   15:#include "MST_graph.hpp"
        -:   16:#include "MST_stats.hpp"
        -:   17:#include "MST_strategy.hpp"
        -:   18:using namespace std;
        -:   19:
        -:   20:// ActiveObject class that processes a task
        -:   21:struct ActiveObject {
        -:   22:    std::thread* workerThread;
        -:   23:    std::queue<void*> tasks;
        -:   24:    std::mutex acMutex;
        -:   25:    std::condition_variable cv;
        -:   26:    bool stopFlag;
        -:   27:    std::function<void(void*, mutex&)> function;  // The function that the worker will execute
        -:   28:    queue<void*>* nextQueueActiveObject;          // Queue for the next ActiveObject
        -:   29:    int id;
        -:   30:
        4:   31:    ActiveObject(std::function<void(void*, mutex&)> func, int id) : stopFlag(false), function(func), workerThread(nullptr), nextQueueActiveObject(nullptr), id(id) {}
        -:   32:
        -:   33:    // Copy constructor
        7:   34:    ActiveObject(const ActiveObject& other)
        7:   35:        : acMutex(), cv(), stopFlag(other.stopFlag), function(other.function), nextQueueActiveObject(other.nextQueueActiveObject), id(other.id) {}
        -:   36:
    #####:   37:    void addTask(void* task) {
        -:   38:        //  std::lock_guard<std::mutex> lock(acMutex);
    #####:   39:        tasks.push(task);
    #####:   40:        cv.notify_one();
        -:   41:        // cout << "Task added to ActiveObject. Queue size: " << tasks.size() << endl;
    #####:   42:    }
        -:   43:
        4:   44:    void runTasks(vector<ActiveObject>& activeObjects, mutex& send_mutex) {
        -:   45:        while (true) {
        -:   46:            void* task;
        -:   47:            {
        4:   48:                std::unique_lock<std::mutex> lock(acMutex);
       12:   49:                cv.wait(lock, [this] { return !tasks.empty() || stopFlag; });
        -:   50:
       4*:   51:                if (stopFlag && tasks.empty()) {
        8:   52:                    return;
        -:   53:                }
        -:   54:
    #####:   55:                if (!tasks.empty()) {
    #####:   56:                    task = tasks.front();
    #####:   57:                    tasks.pop();
        -:   58:                }
        -:   59:
        -:   60:                // Release the current lock before processing
    #####:   61:                lock.unlock();
        -:   62:
    #####:   63:                if (task) {
    #####:   64:                    function(task, send_mutex);
        -:   65:                    // cout << "Task executed. Thread ID: " << std::this_thread::get_id() << endl;
        -:   66:
    #####:   67:                    if (nextQueueActiveObject) {
    #####:   68:                        std::lock_guard<std::mutex> nextLock(activeObjects[id + 1].acMutex);  // Lock before modifying next queue
    #####:   69:                        nextQueueActiveObject->push(task);
    #####:   70:                        activeObjects[id + 1].cv.notify_one();
        -:   71:                        // cout << "Task passed to next ActiveObject. Thread ID: " << std::this_thread::get_id() << endl;
    #####:   72:                    }
        -:   73:                }
       4*:   74:            }
    #####:   75:        }
        -:   76:    }
        -:   77:};
        -:   78:
        -:   79:// Pipeline class that manages multiple ActiveObjects (workers)
        -:   80:class Pipeline {
        -:   81:    // std::mutex mtx_;
        -:   82:    // std::mutex& ansMutex;
        -:   83:    std::condition_variable cv_;
        -:   84:    std::vector<ActiveObject> activeObjects;
        -:   85:    //     // Task 1: Longest Distance
    #####:   86:    static void taskLongestDistance(void* task, mutex& send_mutex) {
    #####:   87:        std::cout << "task type: " << typeid(task).name() << std::endl;
    #####:   88:        auto* taskTuple = static_cast<std::tuple<MST_graph*, string*, int>*>(task);
    #####:   89:        if (taskTuple != nullptr) {
        -:   90:            MST_stats stats;
    #####:   91:            MST_graph* mst_graph = std::get<0>(*taskTuple);
    #####:   92:            string* clientAns = std::get<1>(*taskTuple);
    #####:   93:            if (mst_graph != nullptr && clientAns != nullptr) {
        -:   94:                {
    #####:   95:                    lock_guard<mutex> lock(send_mutex);
    #####:   96:                    *clientAns += "Longest Distance: " + std::to_string(stats.getLongestDistance(*mst_graph)) + "\n";
    #####:   97:                }
        -:   98:            }
        -:   99:        } else {
    #####:  100:            cout << "Error: Invalid task tuple" << endl;
        -:  101:        }
    #####:  102:    }
        -:  103:
        -:  104:    // Task 2: Shortest Distance
    #####:  105:    static void taskShortestDistance(void* task, mutex& send_mutex) {
        -:  106:        //  std::lock_guard<std::mutex> lock(ansMutex);
        -:  107:
        -:  108:        // std::cout << "Thread ID: " << std::this_thread::get_id() << " Calculated shortest distance" << std::endl;
        -:  109:
    #####:  110:        auto* taskTuple = static_cast<tuple<MST_graph*, string*, int>*>(task);
    #####:  111:        MST_graph* mst_graph = std::get<0>(*taskTuple);
    #####:  112:        string* clientAns = std::get<1>(*taskTuple);
        -:  113:
        -:  114:        MST_stats stats;
        -:  115:        {
    #####:  116:            std::lock_guard<std::mutex> lock(send_mutex);
    #####:  117:            *clientAns += "Shortest Distance: " + std::to_string(stats.getShortestDistance(*mst_graph)) + "\n";
    #####:  118:        }
    #####:  119:    }
        -:  120:
        -:  121:    // Task 3: Average Distance
    #####:  122:    static void taskAverageDistance(void* task, mutex& send_mutex) {
        -:  123:        //  std::lock_guard<std::mutex> lock(ansMutex);
        -:  124:
        -:  125:        // std::cout << "Thread ID: " << std::this_thread::get_id() << " Calculated average distance" << std::endl;
        -:  126:
    #####:  127:        auto* taskTuple = static_cast<tuple<MST_graph*, string*, int>*>(task);
    #####:  128:        MST_graph* mst_graph = std::get<0>(*taskTuple);
    #####:  129:        string* clientAns = std::get<1>(*taskTuple);
        -:  130:
        -:  131:        MST_stats stats;
        -:  132:        {
    #####:  133:            std::lock_guard<std::mutex> lock(send_mutex);
    #####:  134:            *clientAns += "Average Distance: " + std::to_string(stats.getAverageDistance(*mst_graph)) + "\n";
    #####:  135:        }
    #####:  136:    }
        -:  137:
        -:  138:    // Task 4: Total Weight
    #####:  139:    static void taskTotalWeight(void* task, mutex& send_mutex) {
        -:  140:        //     std::lock_guard<std::mutex> lock(ansMutex);
        -:  141:
        -:  142:        // std::cout << "Thread ID: " << std::this_thread::get_id() << " Calculated total weight" << std::endl;
        -:  143:
    #####:  144:        auto* taskTuple = static_cast<tuple<MST_graph*, string*, int>*>(task);
    #####:  145:        MST_graph* mst_graph = std::get<0>(*taskTuple);
    #####:  146:        string* clientAns = std::get<1>(*taskTuple);
    #####:  147:        int fdclient = std::get<2>(*taskTuple);
        -:  148:
        -:  149:        MST_stats stats;
        -:  150:        {
    #####:  151:            std::lock_guard<std::mutex> lock(send_mutex);
    #####:  152:            *clientAns += "Total Weight: " + std::to_string(stats.getTotalWeight(*mst_graph)) + "\n";
        -:  153:
    #####:  154:            delete taskTuple;
        -:  155:
        -:  156:            // send the response back to the client
    #####:  157:            if (send(fdclient, clientAns->c_str(), clientAns->size(), 0) == -1) {
    #####:  158:                perror("send");
        -:  159:            }
    #####:  160:        }
    #####:  161:    }
        -:  162:
        -:  163:   public:
        1:  164:    Pipeline() {
        -:  165:        // Create ActiveObjects (workers) for each task
        1:  166:        activeObjects.push_back(ActiveObject(Pipeline::taskLongestDistance, 0));   // Task 1
        1:  167:        activeObjects.push_back(ActiveObject(Pipeline::taskShortestDistance, 1));  // Task 2
        1:  168:        activeObjects.push_back(ActiveObject(Pipeline::taskAverageDistance, 2));   // Task 3
        1:  169:        activeObjects.push_back(ActiveObject(Pipeline::taskTotalWeight, 3));       // Task 4
        -:  170:
        4:  171:        for (int i = 0; i < activeObjects.size() - 1; ++i) {
        3:  172:            activeObjects[i].nextQueueActiveObject = &activeObjects[i + 1].tasks;
        -:  173:        }
        -:  174:        // cout << "Pipeline initialized with " << activeObjects.size() << " ActiveObjects." << endl;
        5:  175:        for (auto& activeObject : activeObjects) {
        -:  176:            // std::mutex* mtx = new std::mutex();                             // creating a new mutex
        -:  177:            //  std::condition_variable* cond = new std::condition_variable();  // creating a new condition variable
        -:  178:            // activeObject.cv = cond;
        -:  179:        }
        1:  180:    }
        -:  181:
        1:  182:    ~Pipeline() {
        1:  183:        stop();  // Ensure all threads are stopped and joined
        -:  184:
        5:  185:        for (auto& activeObject : activeObjects) {
        4:  186:            delete activeObject.workerThread;
        -:  187:        }
        -:  188:        // stop();
        1:  189:    }
        -:  190:
    #####:  191:    void addRequest(void* task) {
    #####:  192:        std::lock_guard<std::mutex> lock(activeObjects[0].acMutex);
    #####:  193:        activeObjects[0].addTask(task);
    #####:  194:        activeObjects[0].cv.notify_one();
        -:  195:        // cout << "Task added to Pipeline (first worker). Initial ActiveObject notified." << endl;
    #####:  196:    }
        -:  197:
        1:  198:    void start(mutex& send_mutex) {
        -:  199:        // cout << "[DEBUG] Pipeline starting all worker threads." << endl;
        5:  200:        for (auto& activeObject : activeObjects) {
        4:  201:            activeObject.workerThread = new std::thread(&ActiveObject::runTasks, &activeObject, std::ref(activeObjects), std::ref(send_mutex));
        -:  202:            // cout << "[DEBUG] Worker thread started for ActiveObject ID: " << activeObject.id << endl;
        -:  203:
        -:  204:            // cout << "[DEBUG] Worker thread started for ActiveObject." << endl;
        -:  205:        }
        1:  206:    }
        1:  207:    void stop() {
        5:  208:        for (auto& activeObject : activeObjects) {
        4:  209:            std::lock_guard<std::mutex> lock(activeObject.acMutex);
        4:  210:            activeObject.stopFlag = true;
        4:  211:            activeObject.cv.notify_one();
        4:  212:        }
        -:  213:
        5:  214:        for (auto& activeObject : activeObjects) {
        4:  215:            if (activeObject.workerThread->joinable()) {
        4:  216:                activeObject.workerThread->join();
        -:  217:            }
        -:  218:        }
        1:  219:    }
        -:  220:};
