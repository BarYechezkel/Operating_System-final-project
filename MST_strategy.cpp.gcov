        -:    0:Source:MST_strategy.cpp
        -:    1:
        -:    2:#include "MST_strategy.hpp"
        -:    3:
        -:    4:constexpr int INF = 0x3f3f3f3f;
        -:    5:
        -:    6:struct Edge {
        -:    7:    int w = INF, to = -1, id;
       16:    8:    bool operator<(Edge const& other) const {
       16:    9:        return make_pair(w, to) < make_pair(other.w, other.to);
        -:   10:    }
        6:   11:    Edge() {
        6:   12:        w = INF;
        6:   13:        to = -1;
        6:   14:    }
       50:   15:    Edge(int _w, int _to, int _id) : w(_w), to(_to), id(_id) {}
        -:   16:};
        -:   17:
        1:   18:MST_graph MST_strategy::kruskal(const vector<tuple<int, int, int, int>>& graph_edges, int n) {
        1:   19:    UnionFind graph(n);
        1:   20:    vector<tuple<int, int, int, int>> edges;
        1:   21:    vector<tuple<int, int, int, int>> spanning_tree;
        -:   22:
        1:   23:    edges = graph_edges;
        -:   24:
        1:   25:    sort(edges.begin(), edges.end(), [&](const tuple<int, int, int, int>& a, const tuple<int, int, int, int>& b) {
       13:   26:        return get<2>(a) < get<2>(b);
        -:   27:    });
        -:   28:
        7:   29:    for (const auto& edge : edges) {
        -:   30:        int from, to, cost, id;
        6:   31:        tie(from, to, cost, id) = edge;
        6:   32:        if (graph.unite(from, to)) {
        2:   33:            spanning_tree.emplace_back(from, to, cost, id);
        -:   34:        }
        -:   35:    }
        -:   36:    // cout << "Kruskal's Algorithm\n";
        2:   37:    return MST_graph(spanning_tree,"kruskal");
        1:   38:}
        -:   39:
        2:   40:vector<tuple<int, int, int, int>> _prim(const vector<vector<Edge>>& adj, int n) {
        2:   41:    vector<tuple<int, int, int, int>> spanning_tree;
        -:   42:
        2:   43:    vector<Edge> min_e(n);
        2:   44:    min_e[0].w = 0;
        2:   45:    set<Edge> q;
        2:   46:    q.insert({0, 0, -1});
        -:   47:
        2:   48:    vector<bool> selected(n, false);
        8:   49:    for (int i = 0; i < n; ++i) {
        6:   50:        int v = q.begin()->to;
        6:   51:        selected[v] = true;
        6:   52:        q.erase(q.begin());
        -:   53:
        6:   54:        if (min_e[v].to != -1) {
        4:   55:            spanning_tree.emplace_back(min_e[v].to, v, min_e[v].w, min_e[v].id);
        -:   56:        }
        -:   57:
       30:   58:        for (Edge e : adj[v]) {
       24:   59:            if (!selected[e.to] && e.w < min_e[e.to].w) {
        8:   60:                q.erase({min_e[e.to].w, e.to, e.id});
        8:   61:                min_e[e.to] = {e.w, v, e.id};
        8:   62:                q.insert({e.w, e.to, e.id});
        -:   63:            }
        -:   64:        }
        -:   65:    }
        4:   66:    return spanning_tree;
        2:   67:}
        -:   68:
        2:   69:MST_graph MST_strategy::prim(const vector<tuple<int, int, int, int>>& edges, int n) {
        -:   70:    // Create an adjacency list with 'n' nodes
        2:   71:    vector<vector<Edge>> adj(n);
        -:   72:
       14:   73:    for (const auto& e : edges) {
        -:   74:        // Unpack the tuple into nodes (u, v), weight, and edge ID
        -:   75:        int u, v, weight, id;
       12:   76:        tie(u, v, weight, id) = e;  // Correct unpacking
        -:   77:
        -:   78:        // Add the edges to the adjacency list
       12:   79:        adj[u].push_back(Edge(weight, v, id));  // Edge from u to v
       12:   80:        adj[v].push_back(Edge(weight, u, id));  // Edge from v to u (undirected graph)
        -:   81:    }
        -:   82:    // Now call your _prim function, assuming it takes adj and n
        2:   83:    vector<tuple<int, int, int, int>> spanning_tree = _prim(adj, n);
        -:   84:
        -:   85:    // cout << "Prim's Algorithm\n";
        -:   86:
        -:   87:    // Return the MST result as a string
        4:   88:    return MST_graph(spanning_tree,"prim");
        2:   89:}
        -:   90:
