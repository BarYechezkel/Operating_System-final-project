        -:    0:Source:main.cpp
        -:    1:#include <arpa/inet.h>   // Include for inet_ntop
        -:    2:#include <netdb.h>       // Include for addrinfo
        -:    3:#include <netinet/in.h>  // Include for sockaddr_in and sockaddr_in6
        -:    4:#include <sys/socket.h>  // Include for sockaddr
        -:    5:#include <unistd.h>      // Include for close
        -:    6:
        -:    7:#include <algorithm>
        -:    8:#include <cassert>
        -:    9:#include <csignal>  // For signal handling (e.g., SIGINT)
        -:   10:#include <cstring>  // Include for memset
        -:   11:#include <ctime>
        -:   12:#include <future>
        -:   13:#include <iostream>
        -:   14:#include <memory>
        -:   15:#include <mutex>
        -:   16:#include <numeric>
        -:   17:#include <random>
        -:   18:#include <set>
        -:   19:#include <sstream>  // Include the necessary header for istringstream
        -:   20:#include <string>
        -:   21:#include <tuple>
        -:   22:#include <unordered_map>
        -:   23:#include <vector>
        -:   24:
        -:   25:#include "Graph.cpp"
        -:   26:#include "GraphGUI.cpp"  // Include the GraphGUI header
        -:   27:#include "LeaderFollowerPool.hpp"
        -:   28:#include "MST_graph.hpp"
        -:   29:#include "MST_stats.hpp"
        -:   30:#include "MST_strategy.hpp"
        -:   31:#include "Pipeline.cpp"
        -:   32:#include "union_find.hpp"
        -:   33:#define PORT "9034"    // port we're listening on
        -:   34:#define NUM_THREADS 4  // Number of threads in the thread pool
        -:   35:using namespace std;
        -:   36:unordered_map<int, tuple<Graph, MST_graph, string>> map_clients;  // Each client gets its own graph
        -:   37:std::mutex lfMutex;                                               // Declare as static to ensure it's shared across function calls
        -:   38:LeaderFollowerPool threadPool(NUM_THREADS, lfMutex);              // Create a thread pool object
        -:   39:Pipeline pipeline;
        -:   40:MST_strategy mst;
        -:   41:atomic<bool> isMST{false};
        -:   42:
        -:   43:// Declare the LeaderFollowerPool instance here
        -:   44:int listener;  // Global listener for shutdown handling
        -:   45:
        -:   46:// Signal handler for graceful shutdown
        4:   47:void shutdown_handler(int signum) {
        -:   48:    // cout << "\nShutting down the server..." << endl;
        4:   49:    close(listener);  // Close the listener socket
        4:   50:    exit(0);          // Exit the program
        -:   51:}
        -:   52:
        -:   53:// assume the input is in the form of "Newgraph n m u v w"
        -:   54:// and the input of edge u v with weight w but dont add the reverse edge with weight w'
        3:   55:vector<tuple<int, int, int, int>> Newgraph(istringstream &iss, int n, int num_of_Edge) {
        3:   56:    vector<tuple<int, int, int, int>> graph;
        -:   57:    // cout << "Newgraph" << endl;
        -:   58:    int u, v, w;  // vertex and weight
       12:   59:    for (int i = 0; i < num_of_Edge; ++i) {
        9:   60:        iss >> u >> v >> w;
        9:   61:        graph.emplace_back(u, v, w, i);
        9:   62:        graph.emplace_back(v, u, w, -2);  // Add the reverse edge for undirected graph
        -:   63:    }
        6:   64:    return graph;
    =====:   65:}
        -:   66:
       29:   67:string graph_user_commands(string input_user, Graph &clientGraph, MST_graph &clientMST, string &clientAns, int fdclient) {
        -:   68:    // Shared string to accumulate results
       29:   69:    string ans;
       29:   70:    string command_of_user;
       29:   71:    istringstream iss(input_user);
       29:   72:    iss >> command_of_user;
        -:   73:
        -:   74:    int n, m;
       29:   75:    std::lock_guard<std::mutex> lock(lfMutex);
        -:   76:
       29:   77:    if (command_of_user.empty()) {
        -:   78:        {
        -:   79:            // std::lock_guard<std::mutex> lock(lfMutex); // Lock before modifying ans
        2:   80:            ans += "No command received.\n";
        -:   81:        }
       27:   82:    } else if (command_of_user == "Newgraph") {
        -:   83:        // Get the number of vertices and edges
        5:   84:        iss >> n >> m;
        5:   85:        if (n <= 0 || m < 0) {
        -:   86:            {
        2:   87:                ans += "Invalid graph parameters. \n";
        -:   88:            }
        -:   89:        } else {
        3:   90:            auto newEdges = Newgraph(iss, n, m);  // Store the result in a local variable
        3:   91:            clientGraph.setEdges(newEdges);       // Pass the local variable to setEdges
        3:   92:            clientGraph.setnumVertices(n);
        -:   93:
        -:   94:            {
        -:   95:                // std::lock_guard<std::mutex> lock(lfMutex); // Lock before modifying ans
        3:   96:                ans += "Graph created:\n";
        3:   97:                ans += clientGraph.toString();
        -:   98:            }
        3:   99:        }
        -:  100:
       22:  101:    } else if (command_of_user == "prim") {
        4:  102:        if (clientGraph.getEdges().empty()) {
        -:  103:            {
        2:  104:                ans += "No graph found.\n";
        -:  105:            }
        -:  106:        } else {
        2:  107:            clientMST = mst.prim(clientGraph.getEdges(), clientGraph.getnumVertices());
        2:  108:            clientMST.setStrategy("prim");
        2:  109:            isMST = true;
        2:  110:            ans += "MST created using Prim's Algorithm.\n";
        2:  111:            ans += clientMST.toString();
        -:  112:        }
        -:  113:
       18:  114:    } else if (command_of_user == "kruskal") {
        3:  115:        if (clientGraph.getEdges().empty()) {
        -:  116:            {
        2:  117:                ans += "No graph found.\n";
        -:  118:            }
        -:  119:        } else {
        1:  120:            clientMST = mst.kruskal(clientGraph.getEdges(), clientGraph.getnumVertices());
        1:  121:            clientMST.setStrategy("kruskal");
        1:  122:            isMST = true;
        1:  123:            ans += "MST created using Kruskal's Algorithm.\n";
        1:  124:            ans += clientMST.toString();
        -:  125:        }
        -:  126:
       15:  127:    } else if (command_of_user == "Newedge") {
        -:  128:        int from, to, weight;
        3:  129:        iss >> from >> to >> weight;
        -:  130:        // cout << "Newedge n: " << n << endl;
        3:  131:        if (clientGraph.getSize() != 0) {
        3:  132:            clientGraph.addEdge(from, to, weight, clientGraph.getSize());
        -:  133:
        3:  134:            ans += "Edge added from " + to_string(from) + " to " + to_string(to) + "\n";
        3:  135:            ans += clientGraph.toString();
        -:  136:        } else {
        -:  137:            {
    #####:  138:                ans += "No graph found for adding edge.\n";
        -:  139:            }
        -:  140:        }
       12:  141:    } else if (command_of_user == "Removeedge") {
        -:  142:        int from, to;
        2:  143:        iss >> from >> to;
        -:  144:        // cout << "Removeedge n: " << n << endl;
        2:  145:        if (clientGraph.getSize() != 0) {
        2:  146:            clientGraph.removeEdge(from, to);
        -:  147:
        2:  148:            ans += "Edge removed from " + to_string(from) + " to " + to_string(to) + "\n";
        2:  149:            ans += clientGraph.toString();
        -:  150:
        -:  151:        } else {
    #####:  152:            ans += "No graph found for removing edge.\n";
        -:  153:        }
       10:  154:    } else if (command_of_user == "Reduceedge") {
        -:  155:        int id, newWeight;
        3:  156:        iss >> id >> newWeight;
        -:  157:        // cout << "Reduceedge n: " << n << endl;
        3:  158:        if (clientGraph.getSize() != 0) {
        3:  159:            clientGraph.reduceEdges(id, newWeight);
        -:  160:
        3:  161:            ans += "Edge reduced with id " + to_string(id) + " to weight " + to_string(newWeight) + "\n";
        3:  162:            ans += clientGraph.toString();
        -:  163:
        -:  164:        } else {
    #####:  165:            ans += "No graph found for reducing edge.\n";
        -:  166:        }
        7:  167:    } else if (command_of_user == "Leader_Follower") {
        3:  168:        if (!isMST) {
        1:  169:            ans += "No MST found.\n";
        -:  170:
        -:  171:        } else {
        -:  172:            // auto clientTask = std::make_tuple(&clientMST, &clientAns,fdclient);
        2:  173:            auto *clientTask = new std::tuple<MST_graph *, std::string *, int>(&clientMST, &clientAns, fdclient);
        -:  174:
        -:  175:            // Pass the pointer to the tuple to the threadPool
        2:  176:            threadPool.addEventHandler(clientTask);
        -:  177:            // Add a small delay to allow Leader_Follower to process
        -:  178:            {
        2:  179:                ans += "done";
        -:  180:            }
        -:  181:        }
        4:  182:    } else if (command_of_user == "Pipeline") {
        2:  183:        if (!isMST) {
    #####:  184:            ans += "No MST found.\n";
        -:  185:        } else {
        2:  186:            auto *clientTask = new std::tuple<MST_graph *, std::string *, int>(&clientMST, &clientAns, fdclient);
        -:  187:            // Pass the pointer to the tuple to the pipeline
        2:  188:            pipeline.addRequest(clientTask);
        -:  189:
        -:  190:            {
        2:  191:                ans += "done";
        -:  192:            }
        -:  193:        }
        -:  194:    } else {
        -:  195:        {
        2:  196:            ans += "Unknown command.\n";
        -:  197:        }
        -:  198:    }
       58:  199:    return ans;
       29:  200:}
        -:  201:
        -:  202:// // get sockaddr, IPv4 or IPv6:
        -:  203:// void *get_in_addr(struct sockaddr *sa) {
        -:  204://     if (sa->sa_family == AF_INET) {
        -:  205://         return &(((struct sockaddr_in *)sa)->sin_addr);
        -:  206://     }
        -:  207://     return &(((struct sockaddr_in6 *)sa)->sin6_addr);
        -:  208:// }
        -:  209:
        -:  210:// vector<tuple<int, int, int, int>> build_random_connected_graph(int n, int m, unsigned int seed) {
        -:  211://     srand(seed);
        -:  212://     assert(m >= (n - 1));
        -:  213://     assert(1ll * m <= (1ll * n * (n - 1)) / 2);
        -:  214:
        -:  215://     vector<int> W(m, 0);
        -:  216://     iota(W.begin(), W.end(), 0);
        -:  217:
        -:  218://     random_device rd;
        -:  219://     mt19937 g(seed);
        -:  220://     shuffle(W.begin(), W.end(), g);
        -:  221:
        -:  222://     vector<tuple<int, int, int, int>> random_graph;
        -:  223://     int nxt = 0;
        -:  224://     set<pair<int, int>> edges;
        -:  225:
        -:  226://     for (int i = 0; i < n - 1; ++i) {
        -:  227://         random_graph.emplace_back(i, i + 1, W[nxt], nxt);
        -:  228://         ++nxt;
        -:  229://         edges.emplace(i, i + 1);
        -:  230://     }
        -:  231:
        -:  232://     int remaining_edges = m - (n - 1);
        -:  233://     for (int e = 0; e < remaining_edges; ++e) {
        -:  234://         int a, b;
        -:  235://         a = (rand() % n);
        -:  236://         b = (rand() % n);
        -:  237://         if (a > b) swap(a, b);
        -:  238://         while (b == a || edges.find(make_pair(a, b)) != edges.end()) {
        -:  239://             a = (rand() % n);
        -:  240://             b = (rand() % n);
        -:  241://             if (a > b) swap(a, b);
        -:  242://         }
        -:  243://         random_graph.emplace_back(a, b, W[nxt], nxt);
        -:  244://         ++nxt;
        -:  245://         edges.emplace(a, b);
        -:  246://     }
        -:  247://     assert(static_cast<int>(random_graph.size()) == m);
        -:  248://     return random_graph;
        -:  249:// }
        4:  250:int main() {
        4:  251:    mutex mtx;
        -:  252:    fd_set master;                          // master file descriptor list
        -:  253:    fd_set read_fds;                        // temp file descriptor list for select()
        -:  254:    int fdmax;                              // maximum file descriptor number
        4:  255:    threadPool.start();                     // Start the LeaderFollowerPool once during server initialization
        4:  256:    pipeline.start(mtx);                    // Start the pipeline once during server initialization
        -:  257:    int newfd;                              // newly accept()ed socket descriptor
        -:  258:    struct sockaddr_storage clientAddress;  // client address
        -:  259:    socklen_t addrlen;
        -:  260:    char buf[4096];  // buffer for client data (increased size)
        -:  261:    int nbytes;
        -:  262:    char remoteIP[INET6_ADDRSTRLEN];
        4:  263:    int yes = 1;  // for setsockopt() SO_REUSEADDR, below
        -:  264:    int i, rv;
        -:  265:    struct addrinfo hints, *ai, *p;
       68:  266:    FD_ZERO(&master);  // clear the master and temp sets
       68:  267:    FD_ZERO(&read_fds);
        -:  268:
        -:  269:    // Set up shutdown signal handler
        4:  270:    signal(SIGINT, shutdown_handler);
        -:  271:    // get us a socket and bind it
        4:  272:    memset(&hints, 0, sizeof hints);
        4:  273:    hints.ai_family = AF_UNSPEC;
        4:  274:    hints.ai_socktype = SOCK_STREAM;
        4:  275:    hints.ai_flags = AI_PASSIVE;
        4:  276:    if ((rv = getaddrinfo(NULL, PORT, &hints, &ai)) != 0) {
    #####:  277:        cerr << "selectserver: " << gai_strerror(rv) << endl;
    #####:  278:        exit(1);
        -:  279:    }
        -:  280:
       4*:  281:    for (p = ai; p != NULL; p = p->ai_next) {
        4:  282:        listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
       4*:  283:        if (listener < 0) {
    #####:  284:            continue;
        -:  285:        }
        -:  286:
        -:  287:        // lose the pesky "address already in use" error message
        4:  288:        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
        -:  289:
       4*:  290:        if (bind(listener, p->ai_addr, p->ai_addrlen) < 0) {
    #####:  291:            close(listener);
    #####:  292:            continue;
        -:  293:        }
        4:  294:        break;
        -:  295:    }
        -:  296:
        4:  297:    if (p == NULL) {
    #####:  298:        cerr << "selectserver: failed to bind" << endl;
    #####:  299:        exit(2);
        -:  300:    }
        -:  301:
        4:  302:    freeaddrinfo(ai);  // all done with this
        -:  303:
        -:  304:    // listen
        4:  305:    if (listen(listener, 10) == -1) {
    #####:  306:        perror("listen");
    #####:  307:        exit(3);
        -:  308:    }
        -:  309:
        -:  310:    // add the listener to the master set
        4:  311:    FD_SET(listener, &master);
        -:  312:
        -:  313:    // keep track of the biggest file descriptor
        4:  314:    fdmax = listener;  // so far, it's this one
        -:  315:
        -:  316:    // cout << "Server is listening on port " << PORT << endl;
        -:  317:
        -:  318:    // main loop
        -:  319:    for (;;) {
       40:  320:        read_fds = master;  // copy it
       40:  321:        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1) {
    #####:  322:            perror("select");
    #####:  323:            exit(4);
        -:  324:        }
        -:  325:
        -:  326:        // run through the existing connections looking for data to read
      216:  327:        for (i = 0; i <= fdmax; i++) {
      180:  328:            if (FD_ISSET(i, &read_fds)) {  // we got one!!
       36:  329:                if (i == listener) {
        -:  330:                    // handle new connections
        4:  331:                    addrlen = sizeof clientAddress;
        4:  332:                    newfd = accept(listener, (struct sockaddr *)&clientAddress, &addrlen);
        -:  333:
        4:  334:                    if (newfd == -1) {
    #####:  335:                        perror("accept");
        -:  336:                    } else {
        4:  337:                        FD_SET(newfd, &master);  // add to master set
        4:  338:                        if (newfd > fdmax) {     // keep track of the max
        4:  339:                            fdmax = newfd;
        -:  340:                        }
        -:  341:                        // cout << "selectserver: new connection from "
        -:  342:                        //      << inet_ntop(clientAddress.ss_family,
        -:  343:                        //                   get_in_addr((struct sockaddr *)&clientAddress),
        -:  344:                        //                   remoteIP, INET6_ADDRSTRLEN)
        -:  345:                        //      << " on socket " << newfd << endl;
        -:  346:
        -:  347:                        // Create a new graph for this client
        4:  348:                        lock_guard<mutex> lock(mtx);
        4:  349:                        std::get<0>(map_clients[newfd]) = Graph();  // Create an empty graph for the new client
        4:  350:                    }
        -:  351:                } else {
        -:  352:                    // handle data from a client
       32:  353:                    if ((nbytes = recv(i, buf, sizeof buf, 0)) <= 0) {
        -:  354:                        // got error or connection closed by client
        3:  355:                        if (nbytes == 0) {
        -:  356:                            // connection closed
        -:  357:                            // cout << "selectserver: socket " << i << " hung up" << endl;
        -:  358:                        } else {
    #####:  359:                            perror("recv");
        -:  360:                        }
        3:  361:                        close(i);            // bye!
        3:  362:                        FD_CLR(i, &master);  // remove from master set
        3:  363:                        lock_guard<mutex> lock(mtx);
        3:  364:                        map_clients.erase(i);  // Remove the client's graph
        3:  365:                    } else {
        -:  366:                        // we got some data from a client
       29:  367:                        buf[nbytes] = '\0';  // null-terminate the buffer
        -:  368:
        -:  369:                        // Process the command for this client
        -:  370:
       29:  371:                        lock_guard<mutex> lock(mtx);
       58:  372:                        string response = graph_user_commands(string(buf), get<0>(map_clients[i]), get<1>(map_clients[i]), get<2>(map_clients[i]), i);
        -:  373:
        -:  374:                        // Send the response back to the client
       29:  375:                        if (send(i, response.c_str(), response.length(), 0) == -1) {
    #####:  376:                            perror("send");
        -:  377:                        }
       29:  378:                    }
        -:  379:                }
        -:  380:            }
        -:  381:        }
       36:  382:    }
        -:  383:    return 0;
        -:  384:}
